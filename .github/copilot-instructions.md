# Copilot Instructions for acts-as-taggable-on-mongoid

- Purpose: Mongoid tagging layer mirroring ActsAsTaggableOn semantics (contexts/tag types, taggers/owners, ordered lists) while persisting tags and taggings in Mongo collections; context is part of the primary key for tags and counts (separate counters per context). See README for full API shape and examples.
- Core entrypoint autoloads all components and injects Taggable/Tagger concerns into Mongoid on load; review [lib/acts-as-taggable-on-mongoid.rb](lib/acts-as-taggable-on-mongoid.rb) before wiring new modules.
- Taggable models declare `acts_as_taggable_on :tags, :skills, ...`; dynamic methods for each context are defined via TagTypeDefinition (list accessors, taggings associations, counts, change tracking). Follow the patterns documented in README when adding contexts so callbacks and caches stay consistent.
- Tag list operations support add/remove/assign, parsing strings via DefaultParser by default; `parse: true` only assumed on assignment/defaults, not on `add` without explicit flag. Ordered tagging is opt-in via `preserve_tag_order` (per-tag definition or global config).
- Taggers: contexts can be tagged per-tagger; tag lists are stored as TaggerTagList internally, and tagger ownership is preserved in taggings for queries and change tracking.
- Global configuration (force_lowercase, force_parameterize, preserve_tag_order, remove_unused_tags, default_parser, tags_table, taggings_table) lives in [lib/acts_as_taggable_on_mongoid/configuration.rb](lib/acts_as_taggable_on_mongoid/configuration.rb). `strict_case_match` and `tags_counter` are intentionally unsupported; use lowercase/parameterize instead.
- Persistence flow: `after_save :save_tags` and `before_save :save_cached_tag_lists` synchronize TagList caches to Tag/Tagging collections; change detection happens in Taggable::Core via TagListDiff to create/destroy taggings and clean up unused tags when configured. See [lib/acts_as_taggable_on_mongoid/taggable/core.rb](lib/acts_as_taggable_on_mongoid/taggable/core.rb) for hook order.
- Defaults: new records can receive default tag lists per context (including default tagger) before first persistence; values are populated unless the instance variable already exists. Keep this in mind when manually setting tag lists in constructors.
- Query helpers: contexts expose `all_<context>_tags`, `<context>_list`, `<context>_counts`, and tagger-specific variants; ordering is applied via taggings order when `preserve_tag_order` is true. Prefer these helpers over manual criteria to keep context scoping intact.
- Custom tag/tagging models: override `tags_table` and `taggings_table` per context or globally (configuration) but ensure fields/scopes mirror the provided Models::Tag/Tagging behavior; `find_or_create_tags_from_list_with_context` is the hook for custom creation.
- Parsing: Default delimiter is comma; create custom parsers by subclassing GenericParser and pass `parser:` per tag definition or assignment when necessary.
- Testing: requires a local MongoDB on localhost:27017; test DB name `acts_as_taggable_on_mongoid_test` from [spec/fixtures/mongoid.yml](spec/fixtures/mongoid.yml). Specs clean via DatabaseCleaner truncation around each example ([spec/support/database_cleaner.rb](spec/support/database_cleaner.rb)).
- Run tests with `bundle exec rspec` (or `bundle exec rake`, default task is :spec per [Rakefile](Rakefile)). Coverage uses SimpleCov HTML out of [spec/rails_helper.rb](spec/rails_helper.rb).
- When debugging tagging changes, inspect TagList caches and `tag_list_changes` recorded in Taggable::Core; ensure `save_tags` is invoked via normal save cycle—manual persistence should call `save` on taggable models to trigger callbacks.
- Style: all Ruby files use frozen string literal; prefer idiomatic Ruby/Mongoid (Criteria, scopes). Respect existing module autoload structure and keep new concerns under the appropriate namespace for eager loading.
- Example setup pattern: include Mongoid::Document, declare `acts_as_taggable` or `acts_as_taggable_on :skills, :interests`, permit `<context>_list` params in controllers, and rely on `*_list.add/remove` plus assignment semantics as demonstrated in README.
- External dependencies: Mongoid, ActiveSupport, RSpec, DatabaseCleaner, Timecop; ensure gem is required as `acts-as-taggable-on-mongoid` in host apps.
- If adding new contexts or configuration knobs, extend both the tag definition layer and tests—mirror existing specs in spec/acts_as_taggable_mongoid for API coverage.

Feedback: If any section is unclear or missing (e.g., custom parser setup, tagger ownership flows, or query helpers), let me know which areas to expand.
